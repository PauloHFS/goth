// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: core.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const cancelJob = `-- name: CancelJob :exec
UPDATE jobs SET status = 'cancelled', updated_at = CURRENT_TIMESTAMP WHERE id = ? AND status = 'pending'
`

func (q *Queries) CancelJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, cancelJob, id)
	return err
}

const cleanupDeadLetterJobs = `-- name: CleanupDeadLetterJobs :exec
DELETE FROM dead_letter_jobs 
WHERE failed_at < datetime('now', '-14 days')
`

func (q *Queries) CleanupDeadLetterJobs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupDeadLetterJobs)
	return err
}

const completeJob = `-- name: CompleteJob :exec
UPDATE jobs 
SET status = 'completed', updated_at = CURRENT_TIMESTAMP 
WHERE id = ?
`

func (q *Queries) CompleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, completeJob, id)
	return err
}

const countDeadLetterJobs = `-- name: CountDeadLetterJobs :one
SELECT COUNT(*) FROM dead_letter_jobs
`

func (q *Queries) CountDeadLetterJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeadLetterJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeadLetterJobsByType = `-- name: CountDeadLetterJobsByType :one
SELECT COUNT(*) FROM dead_letter_jobs WHERE type = ?
`

func (q *Queries) CountDeadLetterJobsByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeadLetterJobsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobs = `-- name: CountJobs :one
SELECT COUNT(*) FROM jobs WHERE (? = '' OR status = ?)
`

type CountJobsParams struct {
	Column1 interface{} `json:"column_1"`
	Status  string      `json:"status"`
}

func (q *Queries) CountJobs(ctx context.Context, arg CountJobsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobs, arg.Column1, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users WHERE tenant_id = ?
`

func (q *Queries) CountUsers(ctx context.Context, tenantID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (tenant_id, type, payload, run_at) VALUES (?, ?, ?, ?) RETURNING id, tenant_id, type, payload, status, idempotency_key, attempt_count, max_attempts, last_error, run_at, started_at, completed_at, created_at, updated_at
`

type CreateJobParams struct {
	TenantID sql.NullString  `json:"tenant_id"`
	Type     string          `json:"type"`
	Payload  json.RawMessage `json:"payload"`
	RunAt    sql.NullTime    `json:"run_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.TenantID,
		arg.Type,
		arg.Payload,
		arg.RunAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.IdempotencyKey,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.RunAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (tenant_id, email, password_hash, role_id) 
VALUES (?, ?, ?, ?) RETURNING id, tenant_id, email, password_hash, role_id, is_verified, is_active, avatar_url, last_login_at, created_at, updated_at
`

type CreateUserParams struct {
	TenantID     string `json:"tenant_id"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	RoleID       string `json:"role_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.TenantID,
		arg.Email,
		arg.PasswordHash,
		arg.RoleID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsVerified,
		&i.IsActive,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (source, external_id, payload, headers) 
VALUES (?, ?, ?, ?) RETURNING id, source, external_id, payload, headers, status, processed_at, error_message, created_at
`

type CreateWebhookParams struct {
	Source     string          `json:"source"`
	ExternalID sql.NullString  `json:"external_id"`
	Payload    json.RawMessage `json:"payload"`
	Headers    json.RawMessage `json:"headers"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook,
		arg.Source,
		arg.ExternalID,
		arg.Payload,
		arg.Headers,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.ExternalID,
		&i.Payload,
		&i.Headers,
		&i.Status,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDeadLetterJob = `-- name: DeleteDeadLetterJob :exec
DELETE FROM dead_letter_jobs WHERE id = ?
`

func (q *Queries) DeleteDeadLetterJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDeadLetterJob, id)
	return err
}

const deleteEmailVerification = `-- name: DeleteEmailVerification :exec
DELETE FROM email_verifications WHERE email = ?
`

func (q *Queries) DeleteEmailVerification(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailVerification, email)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE id = ?
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const deletePasswordReset = `-- name: DeletePasswordReset :exec
DELETE FROM password_resets WHERE email = ?
`

func (q *Queries) DeletePasswordReset(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deletePasswordReset, email)
	return err
}

const failJob = `-- name: FailJob :exec
UPDATE jobs SET status = 'failed', last_error = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type FailJobParams struct {
	LastError sql.NullString `json:"last_error"`
	ID        int64          `json:"id"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.ExecContext(ctx, failJob, arg.LastError, arg.ID)
	return err
}

const getDeadLetterJob = `-- name: GetDeadLetterJob :one
SELECT id, original_job_id, tenant_id, type, payload, attempt_count, last_error, failed_at, created_at, archived_at FROM dead_letter_jobs WHERE id = ?
`

func (q *Queries) GetDeadLetterJob(ctx context.Context, id int64) (DeadLetterJob, error) {
	row := q.db.QueryRowContext(ctx, getDeadLetterJob, id)
	var i DeadLetterJob
	err := row.Scan(
		&i.ID,
		&i.OriginalJobID,
		&i.TenantID,
		&i.Type,
		&i.Payload,
		&i.AttemptCount,
		&i.LastError,
		&i.FailedAt,
		&i.CreatedAt,
		&i.ArchivedAt,
	)
	return i, err
}

const getEmailVerificationByToken = `-- name: GetEmailVerificationByToken :one
SELECT id, email, token, expires_at, created_at FROM email_verifications WHERE token = ? LIMIT 1
`

func (q *Queries) GetEmailVerificationByToken(ctx context.Context, token string) (EmailVerification, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationByToken, token)
	var i EmailVerification
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPasswordResetByToken = `-- name: GetPasswordResetByToken :one
SELECT id, email, token_hash, expires_at, used_at, created_at FROM password_resets WHERE token_hash = ? LIMIT 1
`

func (q *Queries) GetPasswordResetByToken(ctx context.Context, tokenHash string) (PasswordReset, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetByToken, tokenHash)
	var i PasswordReset
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, name, settings, created_at, updated_at FROM tenants WHERE id = ? LIMIT 1
`

func (q *Queries) GetTenantByID(ctx context.Context, id string) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, tenant_id, email, password_hash, role_id, is_verified, is_active, avatar_url, last_login_at, created_at, updated_at FROM users WHERE tenant_id = ? AND email = ? LIMIT 1
`

type GetUserByEmailParams struct {
	TenantID string `json:"tenant_id"`
	Email    string `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsVerified,
		&i.IsActive,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, tenant_id, email, password_hash, role_id, is_verified, is_active, avatar_url, last_login_at, created_at, updated_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsVerified,
		&i.IsActive,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isJobProcessed = `-- name: IsJobProcessed :one
SELECT EXISTS(SELECT 1 FROM processed_jobs WHERE job_id = ?)
`

func (q *Queries) IsJobProcessed(ctx context.Context, jobID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, isJobProcessed, jobID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listDeadLetterJobs = `-- name: ListDeadLetterJobs :many
SELECT id, original_job_id, tenant_id, type, payload, attempt_count, last_error, failed_at, created_at, archived_at FROM dead_letter_jobs 
WHERE (?1 = '' OR type = ?1) 
ORDER BY failed_at DESC 
LIMIT ?2 OFFSET ?3
`

type ListDeadLetterJobsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int64       `json:"limit"`
	Offset  int64       `json:"offset"`
}

func (q *Queries) ListDeadLetterJobs(ctx context.Context, arg ListDeadLetterJobsParams) ([]DeadLetterJob, error) {
	rows, err := q.db.QueryContext(ctx, listDeadLetterJobs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeadLetterJob
	for rows.Next() {
		var i DeadLetterJob
		if err := rows.Scan(
			&i.ID,
			&i.OriginalJobID,
			&i.TenantID,
			&i.Type,
			&i.Payload,
			&i.AttemptCount,
			&i.LastError,
			&i.FailedAt,
			&i.CreatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobs = `-- name: ListJobs :many

SELECT id, tenant_id, type, payload, status, idempotency_key, attempt_count, max_attempts, last_error, run_at, started_at, completed_at, created_at, updated_at FROM jobs 
WHERE (?1 = '' OR status = ?1)
ORDER BY created_at DESC 
LIMIT ?2 OFFSET ?3
`

type ListJobsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int64       `json:"limit"`
	Offset  int64       `json:"offset"`
}

// === JOBS MANAGEMENT ===
func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, listJobs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Type,
			&i.Payload,
			&i.Status,
			&i.IdempotencyKey,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.LastError,
			&i.RunAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersPaginated = `-- name: ListUsersPaginated :many
SELECT id, tenant_id, email, password_hash, role_id, is_verified, is_active, avatar_url, last_login_at, created_at, updated_at FROM users 
WHERE tenant_id = ? 
AND (email LIKE '%' || ? || '%' OR ? = '')
ORDER BY created_at DESC 
LIMIT ? OFFSET ?
`

type ListUsersPaginatedParams struct {
	TenantID string         `json:"tenant_id"`
	Column2  sql.NullString `json:"column_2"`
	Column3  interface{}    `json:"column_3"`
	Limit    int64          `json:"limit"`
	Offset   int64          `json:"offset"`
}

func (q *Queries) ListUsersPaginated(ctx context.Context, arg ListUsersPaginatedParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersPaginated,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.PasswordHash,
			&i.RoleID,
			&i.IsVerified,
			&i.IsActive,
			&i.AvatarUrl,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveToDeadLetter = `-- name: MoveToDeadLetter :exec

INSERT INTO dead_letter_jobs (original_job_id, tenant_id, type, payload, attempt_count, last_error)
SELECT jobs.id, jobs.tenant_id, jobs.type, jobs.payload, jobs.attempt_count, jobs.last_error FROM jobs WHERE jobs.id = ?
`

// === DEAD LETTER QUEUE ===
func (q *Queries) MoveToDeadLetter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, moveToDeadLetter, id)
	return err
}

const pickNextJob = `-- name: PickNextJob :one
UPDATE jobs 
SET status = 'processing', updated_at = CURRENT_TIMESTAMP
WHERE id = (
    SELECT id FROM jobs 
    WHERE status = 'pending' AND run_at <= CURRENT_TIMESTAMP 
    ORDER BY run_at ASC LIMIT 1
) RETURNING id, tenant_id, type, payload, status, idempotency_key, attempt_count, max_attempts, last_error, run_at, started_at, completed_at, created_at, updated_at
`

func (q *Queries) PickNextJob(ctx context.Context) (Job, error) {
	row := q.db.QueryRowContext(ctx, pickNextJob)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.IdempotencyKey,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.RunAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const recordJobProcessed = `-- name: RecordJobProcessed :exec
INSERT INTO processed_jobs (job_id) VALUES (?)
ON CONFLICT(job_id) DO UPDATE SET processed_at = CURRENT_TIMESTAMP
`

func (q *Queries) RecordJobProcessed(ctx context.Context, jobID int64) error {
	_, err := q.db.ExecContext(ctx, recordJobProcessed, jobID)
	return err
}

const reprocessDeadLetterJob = `-- name: ReprocessDeadLetterJob :one
INSERT INTO jobs (tenant_id, type, payload, run_at)
SELECT tenant_id, type, payload, CURRENT_TIMESTAMP FROM dead_letter_jobs WHERE dead_letter_jobs.id = ?
RETURNING id, tenant_id, type, payload, status, idempotency_key, attempt_count, max_attempts, last_error, run_at, started_at, completed_at, created_at, updated_at
`

func (q *Queries) ReprocessDeadLetterJob(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRowContext(ctx, reprocessDeadLetterJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.IdempotencyKey,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.RunAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const rescueZombies = `-- name: RescueZombies :exec
UPDATE jobs 
SET status = 'pending', attempt_count = attempt_count + 1 
WHERE status = 'processing' AND updated_at < datetime('now', '-5 minutes')
`

func (q *Queries) RescueZombies(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, rescueZombies)
	return err
}

const retryJob = `-- name: RetryJob :exec
UPDATE jobs SET status = 'pending', attempt_count = 0, last_error = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) RetryJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, retryJob, id)
	return err
}

const updateUserAvatar = `-- name: UpdateUserAvatar :exec
UPDATE users SET avatar_url = ? WHERE id = ?
`

type UpdateUserAvatarParams struct {
	AvatarUrl sql.NullString `json:"avatar_url"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAvatar, arg.AvatarUrl, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = ? WHERE email = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	Email        string `json:"email"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.Email)
	return err
}

const upsertEmailVerification = `-- name: UpsertEmailVerification :exec
INSERT INTO email_verifications (email, token, expires_at) 
VALUES (?, ?, ?)
ON CONFLICT(email) DO UPDATE SET 
    token = excluded.token,
    expires_at = excluded.expires_at
`

type UpsertEmailVerificationParams struct {
	Email     string    `json:"email"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) UpsertEmailVerification(ctx context.Context, arg UpsertEmailVerificationParams) error {
	_, err := q.db.ExecContext(ctx, upsertEmailVerification, arg.Email, arg.Token, arg.ExpiresAt)
	return err
}

const upsertPasswordReset = `-- name: UpsertPasswordReset :exec
INSERT INTO password_resets (email, token_hash, expires_at) 
VALUES (?, ?, ?)
ON CONFLICT(token_hash) DO UPDATE SET 
    email = excluded.email,
    expires_at = excluded.expires_at
`

type UpsertPasswordResetParams struct {
	Email     string    `json:"email"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) UpsertPasswordReset(ctx context.Context, arg UpsertPasswordResetParams) error {
	_, err := q.db.ExecContext(ctx, upsertPasswordReset, arg.Email, arg.TokenHash, arg.ExpiresAt)
	return err
}

const verifyUser = `-- name: VerifyUser :exec
UPDATE users SET is_verified = TRUE WHERE email = ?
`

func (q *Queries) VerifyUser(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, verifyUser, email)
	return err
}
