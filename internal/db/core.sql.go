// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: core.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const completeJob = `-- name: CompleteJob :exec
UPDATE jobs 
SET status = 'completed', updated_at = CURRENT_TIMESTAMP 
WHERE id = ?
`

func (q *Queries) CompleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, completeJob, id)
	return err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users WHERE tenant_id = ?
`

func (q *Queries) CountUsers(ctx context.Context, tenantID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (tenant_id, type, payload, run_at) VALUES (?, ?, ?, ?) RETURNING id, tenant_id, type, payload, status, idempotency_key, attempt_count, max_attempts, last_error, run_at, created_at, updated_at
`

type CreateJobParams struct {
	TenantID sql.NullString  `json:"tenant_id"`
	Type     string          `json:"type"`
	Payload  json.RawMessage `json:"payload"`
	RunAt    sql.NullTime    `json:"run_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.TenantID,
		arg.Type,
		arg.Payload,
		arg.RunAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.IdempotencyKey,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.RunAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (tenant_id, email, password_hash, role_id) 
VALUES (?, ?, ?, ?) RETURNING id, tenant_id, email, password_hash, role_id, is_verified, avatar_url, created_at
`

type CreateUserParams struct {
	TenantID     string `json:"tenant_id"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	RoleID       string `json:"role_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.TenantID,
		arg.Email,
		arg.PasswordHash,
		arg.RoleID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsVerified,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (source, external_id, payload, headers) 
VALUES (?, ?, ?, ?) RETURNING id, source, external_id, payload, headers, status, created_at
`

type CreateWebhookParams struct {
	Source     string          `json:"source"`
	ExternalID sql.NullString  `json:"external_id"`
	Payload    json.RawMessage `json:"payload"`
	Headers    json.RawMessage `json:"headers"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook,
		arg.Source,
		arg.ExternalID,
		arg.Payload,
		arg.Headers,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.ExternalID,
		&i.Payload,
		&i.Headers,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmailVerification = `-- name: DeleteEmailVerification :exec
DELETE FROM email_verifications WHERE email = ?
`

func (q *Queries) DeleteEmailVerification(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailVerification, email)
	return err
}

const deletePasswordReset = `-- name: DeletePasswordReset :exec
DELETE FROM password_resets WHERE email = ?
`

func (q *Queries) DeletePasswordReset(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deletePasswordReset, email)
	return err
}

const failJob = `-- name: FailJob :exec
UPDATE jobs SET status = 'failed', last_error = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type FailJobParams struct {
	LastError sql.NullString `json:"last_error"`
	ID        int64          `json:"id"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.ExecContext(ctx, failJob, arg.LastError, arg.ID)
	return err
}

const getEmailVerificationByToken = `-- name: GetEmailVerificationByToken :one
SELECT email, token, expires_at, created_at FROM email_verifications WHERE token = ? LIMIT 1
`

func (q *Queries) GetEmailVerificationByToken(ctx context.Context, token string) (EmailVerification, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationByToken, token)
	var i EmailVerification
	err := row.Scan(
		&i.Email,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPasswordResetByToken = `-- name: GetPasswordResetByToken :one
SELECT email, token_hash, expires_at, created_at FROM password_resets WHERE token_hash = ? LIMIT 1
`

func (q *Queries) GetPasswordResetByToken(ctx context.Context, tokenHash string) (PasswordReset, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetByToken, tokenHash)
	var i PasswordReset
	err := row.Scan(
		&i.Email,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, name, settings, created_at FROM tenants WHERE id = ? LIMIT 1
`

func (q *Queries) GetTenantByID(ctx context.Context, id string) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Settings,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, tenant_id, email, password_hash, role_id, is_verified, avatar_url, created_at FROM users WHERE tenant_id = ? AND email = ? LIMIT 1
`

type GetUserByEmailParams struct {
	TenantID string `json:"tenant_id"`
	Email    string `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsVerified,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, tenant_id, email, password_hash, role_id, is_verified, avatar_url, created_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsVerified,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const isJobProcessed = `-- name: IsJobProcessed :one
SELECT EXISTS(SELECT 1 FROM processed_jobs WHERE job_id = ?)
`

func (q *Queries) IsJobProcessed(ctx context.Context, jobID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, isJobProcessed, jobID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listUsersPaginated = `-- name: ListUsersPaginated :many
SELECT id, tenant_id, email, password_hash, role_id, is_verified, avatar_url, created_at FROM users 
WHERE tenant_id = ? 
AND (email LIKE '%' || ? || '%' OR ? = '')
ORDER BY created_at DESC 
LIMIT ? OFFSET ?
`

type ListUsersPaginatedParams struct {
	TenantID string         `json:"tenant_id"`
	Column2  sql.NullString `json:"column_2"`
	Column3  interface{}    `json:"column_3"`
	Limit    int64          `json:"limit"`
	Offset   int64          `json:"offset"`
}

func (q *Queries) ListUsersPaginated(ctx context.Context, arg ListUsersPaginatedParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersPaginated,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.PasswordHash,
			&i.RoleID,
			&i.IsVerified,
			&i.AvatarUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pickNextJob = `-- name: PickNextJob :one
UPDATE jobs 
SET status = 'processing', updated_at = CURRENT_TIMESTAMP
WHERE id = (
    SELECT id FROM jobs 
    WHERE status = 'pending' AND run_at <= CURRENT_TIMESTAMP 
    ORDER BY run_at ASC LIMIT 1
) RETURNING id, tenant_id, type, payload, status, idempotency_key, attempt_count, max_attempts, last_error, run_at, created_at, updated_at
`

func (q *Queries) PickNextJob(ctx context.Context) (Job, error) {
	row := q.db.QueryRowContext(ctx, pickNextJob)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.IdempotencyKey,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.RunAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const recordJobProcessed = `-- name: RecordJobProcessed :exec
INSERT INTO processed_jobs (job_id) VALUES (?)
ON CONFLICT(job_id) DO UPDATE SET processed_at = CURRENT_TIMESTAMP
`

func (q *Queries) RecordJobProcessed(ctx context.Context, jobID int64) error {
	_, err := q.db.ExecContext(ctx, recordJobProcessed, jobID)
	return err
}

const rescueZombies = `-- name: RescueZombies :exec
UPDATE jobs 
SET status = 'pending', attempt_count = attempt_count + 1 
WHERE status = 'processing' AND updated_at < datetime('now', '-5 minutes')
`

func (q *Queries) RescueZombies(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, rescueZombies)
	return err
}

const updateUserAvatar = `-- name: UpdateUserAvatar :exec
UPDATE users SET avatar_url = ? WHERE id = ?
`

type UpdateUserAvatarParams struct {
	AvatarUrl sql.NullString `json:"avatar_url"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAvatar, arg.AvatarUrl, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = ? WHERE email = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	Email        string `json:"email"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.Email)
	return err
}

const upsertEmailVerification = `-- name: UpsertEmailVerification :exec
INSERT INTO email_verifications (email, token, expires_at) 
VALUES (?, ?, ?)
ON CONFLICT(email) DO UPDATE SET 
    token = excluded.token,
    expires_at = excluded.expires_at
`

type UpsertEmailVerificationParams struct {
	Email     string    `json:"email"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) UpsertEmailVerification(ctx context.Context, arg UpsertEmailVerificationParams) error {
	_, err := q.db.ExecContext(ctx, upsertEmailVerification, arg.Email, arg.Token, arg.ExpiresAt)
	return err
}

const upsertPasswordReset = `-- name: UpsertPasswordReset :exec
INSERT INTO password_resets (email, token_hash, expires_at) 
VALUES (?, ?, ?)
ON CONFLICT(token_hash) DO UPDATE SET 
    email = excluded.email,
    expires_at = excluded.expires_at
`

type UpsertPasswordResetParams struct {
	Email     string    `json:"email"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) UpsertPasswordReset(ctx context.Context, arg UpsertPasswordResetParams) error {
	_, err := q.db.ExecContext(ctx, upsertPasswordReset, arg.Email, arg.TokenHash, arg.ExpiresAt)
	return err
}

const verifyUser = `-- name: VerifyUser :exec
UPDATE users SET is_verified = TRUE WHERE email = ?
`

func (q *Queries) VerifyUser(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, verifyUser, email)
	return err
}
